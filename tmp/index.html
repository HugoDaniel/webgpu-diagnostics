<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebGPU Diagnostics</title>

<style>
  :root{
    --bg: #0b0f14;
    --panel:#11161d;
    --muted:#8a97a7;
    --text:#e8eef6;
    --brand:#6c8cff;
    --ok:#2ec27e;
    --bad:#ff6b6b;
    --border: #1f2a36;
    --shadow: 0 4px 20px rgba(0,0,0,.25);
    --radius: 14px;
    --gap: 16px;
  }
  @media (prefers-color-scheme: light){
    :root{
      --bg:#f6f8fb; --panel:#ffffff; --muted:#667085; --text:#0b1220;
      --brand:#3b5bfd; --ok:#198754; --bad:#e44; --border:#e7ecf3;
      --shadow: 0 6px 24px rgba(16,24,40,.08);
    }
  }

  /* Reset minimal */
  *{box-sizing:border-box}
  html{color-scheme: light dark}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font: 400 16px/1.55 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
  }

  /* Layout */
  header{
    position: sticky; top:0; z-index:10;
    backdrop-filter: saturate(1.2) blur(8px);
    background: color-mix(in oklab, var(--bg) 70%, transparent);
    border-bottom: 1px solid var(--border);
  }
  .wrap{
    max-width: 1000px;
    margin-inline:auto;
    padding: 16px clamp(14px, 2vw, 24px);
  }
  .titlebar{
    display:flex; align-items:center; gap:12px; justify-content:space-between;
  }
  h1{
    margin:0;
    font-weight:700;
    letter-spacing:.2px;
    font-size: clamp(18px, 2vw + 8px, 24px);
  }
  .badge{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:999px; font-weight:600; font-size:12px;
    border:1px solid var(--border);
    background:var(--panel);
    box-shadow: var(--shadow);
  }
  .badge .dot{width:8px;height:8px;border-radius:50%; background:var(--brand)}
  .badge.ok .dot{background:var(--ok)}
  .badge.bad .dot{background:var(--bad)}

  /* Canvas card */
  .panel {
    background:var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
  }
  .canvas-card{overflow:hidden}
  .canvas-head{
    display:flex; align-items:center; justify-content:space-between;
    padding: 12px 14px; border-bottom:1px solid var(--border);
  }
  .canvas-head span{color:var(--muted); font-size:13px}
  .canvas{
    width:100%; display:block; aspect-ratio: 16/9; /* responsive */
  }

  /* Grid */
  .grid{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: var(--gap);
  }
  .card{
    padding:14px;
  }
  .card h3{
    margin:0 0 10px; font-size: clamp(14px, 1.2vw + 10px, 16px);
    font-weight:600;
  }
  .list{display:flex; flex-direction:column; gap:8px}
  .row{
    display:flex; align-items:center; justify-content:space-between;
    gap:12px; font-size:13px; color:var(--muted);
    padding:6px 0; border-bottom:1px dashed color-mix(in oklab, var(--border) 70%, transparent);
  }
  .row:last-child{border-bottom:0}
  .val{color:var(--text); font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .tags{display:flex; flex-wrap:wrap; gap:6px}
  .tag{
    font-size:12px; padding:4px 8px; border-radius:999px;
    border:1px solid var(--border); background: color-mix(in oklab, var(--panel) 70%, transparent);
  }

  .limits{
    display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:10px;
    max-height: 360px; overflow:auto;
  }
  .limit{
    padding:10px; border:1px solid var(--border); border-radius:10px;
    display:grid; gap:6px; background: color-mix(in oklab, var(--panel) 85%, transparent);
  }
  .limit .name{
    font-size:12px;
    color:var(--muted);
    word-break:break-word;
    overflow-wrap:anywhere;
  }
  .limit .num{
    font-weight:600;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    overflow-wrap:anywhere;
  }

  /* Loading (minimal) */
  .loading{
    position:fixed; inset:0; display:grid; place-items:center; background:var(--bg);
  }
  .spinner{
    width:28px;height:28px; border-radius:50%;
    border:3px solid color-mix(in oklab, var(--muted) 30%, transparent);
    border-top-color: var(--brand); animation:spin 1s linear infinite;
  }
  @keyframes spin{to{transform: rotate(1turn)}}
  @media (prefers-reduced-motion: reduce){
    .spinner{animation:none}
  }

  /* Small helpers */
  .muted{color:var(--muted); font-size:12px}
  .pad{padding: clamp(12px, 2.5vw, 18px)}
  .mt{margin-top: var(--gap)}
</style>
</head>
<body>
  <!-- Loading -->
  <div id="loading" class="loading" role="status" aria-live="polite">
    <div class="spinner" aria-hidden="true"></div>
  </div>

  <header>
    <div class="wrap titlebar">
      <h1>WebGPU Diagnostics</h1>
      <div id="status" class="badge"><span class="dot"></span><span id="statusText">Initializing…</span></div>
    </div>
  </header>

  <main class="wrap">
    <!-- Canvas -->
    <section class="panel canvas-card">
      <div class="canvas-head">
        <strong>Preview</strong>
        <span id="canvasInfo" class="muted">—</span>
      </div>
      <div class="pad">
        <canvas id="c" class="canvas"></canvas>
      </div>
    </section>

    <!-- Grid -->
    <section class="grid mt">
      <article class="panel card" id="timingsCard">
        <h3>Timings</h3>
        <div class="list" id="timings"></div>
      </article>

      <article class="panel card" id="featuresCard">
        <h3>Features</h3>
        <div class="tags" id="features"></div>
      </article>

      <article class="panel card" id="adapterInfoCard">
        <h3>Adapter Info</h3>
        <div class="list" id="adapterInfo"></div>
      </article>

      <article class="panel card" id="warningsCard" hidden>
        <h3>Warnings</h3>
        <div class="list" id="warnings"></div>
      </article>

      <article class="panel card" id="errorsCard" hidden>
        <h3>Errors</h3>
        <div class="list" id="errors"></div>
      </article>

      <article class="panel card" id="adapterCard" style="grid-column:1 / -1">
        <h3>Adapter Limits</h3>
        <div class="limits" id="adapterLimits"></div>
      </article>

      <article class="panel card" id="deviceCard" style="grid-column:1 / -1">
        <h3>Device Limits</h3>
        <div class="limits" id="deviceLimits"></div>
      </article>
    </section>
  </main>

<script type="module">
  const $ = (id) => document.getElementById(id);
  const loadingEl = $("loading");
  const statusEl = $("status");
  const statusText = $("statusText");
  const canvas = $("c");
  const canvasInfo = $("canvasInfo");
  const adapterInfoEl = $("adapterInfo");
  const warningsCard = $("warningsCard");
  const warningsEl = $("warnings");
  const errorsCard = $("errorsCard");
  const errorsEl = $("errors");

  const uiState = {
    summary: null,
    info: null,
    features: { adapter: [], device: [] },
    limits: { adapter: {}, device: {} },
  };

  let deviceRef = null;
  let contextRef = null;
  let canvasFormat = null;
  let resizeObserver = null;

  function emptySummary() {
    return {
      timings: {},
      errors: [],
      warnings: [],
      errorScopes: [],
      adapterLimits: {},
      deviceLimits: {},
      success: false,
    };
  }

  function setStatus(ok, msg) {
    statusEl.className = "badge " + (ok ? "ok" : "bad");
    statusText.textContent = msg;
  }

  function resizeCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));

    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      canvas.style.touchAction = "none";
      canvasInfo.textContent = `${Math.floor(rect.width)}×${Math.floor(rect.height)} CSS — DPR ${dpr.toFixed(2)} — ${w}×${h} px`;

      if (contextRef && deviceRef) {
        const format = canvasFormat || navigator.gpu.getPreferredCanvasFormat();
        contextRef.configure({
          device: deviceRef,
          format,
          alphaMode: "premultiplied",
        });
      }
    }
  }

  function renderTimings(timings) {
    const entries = Object.entries(timings || {});
    if (entries.length === 0) {
      return '<div class="muted">No timings collected.</div>';
    }

    return entries
      .sort(([a], [b]) => a.localeCompare(b))
      .map(
        ([key, value]) =>
          `<div class="row"><span>${key}</span><span class="val">${value.toFixed(2)} ms</span></div>`,
      )
      .join("");
  }

  function renderLimits(limits) {
    const entries = Object.entries(limits || {});
    if (entries.length === 0) {
      return '<div class="muted">No limits.</div>';
    }

    return entries
      .sort(([a], [b]) => a.localeCompare(b))
      .map(
        ([key, value]) => {
          const displayValue =
            typeof value === "number" && Number.isFinite(value)
              ? value.toLocaleString()
              : value;
          return `<div class="limit"><div class="name">${key}</div><div class="num">${displayValue}</div></div>`;
        },
      )
      .join("");
  }

  function renderAdapterInfo(info) {
    const defaults = {
      vendor: null,
      architecture: null,
      device: null,
      description: null,
      driver: null,
      backend: null,
      type: null,
      isFallbackAdapter: null,
    };

    const labels = {
      vendor: "Vendor",
      architecture: "Architecture",
      // device: "Device",
      // description: "Description",
      // driver: "Driver",
      // backend: "Backend",
      // type: "Type",
      // isFallbackAdapter: "Fallback Adapter",
    };

    const data = { ...defaults, ...(info || {}) };
    const unknownTokens = new Set(["unknown", "Unknown", "", null, undefined]);

    let knownCount = 0;
    let unknownCount = 0;

    const rows = Object.entries(labels)
      .map(([key, label]) => {
        let value = data[key];

        if (key === "isFallbackAdapter") {
          if (value === null) {
            unknownCount++;
            value = "Unknown";
          } else {
            knownCount++;
            value = value ? "Yes" : "No";
          }
        } else if (unknownTokens.has(value)) {
          unknownCount++;
          value = "Unknown";
        } else {
          knownCount++;
        }

        return `<div class="row"><span>${label}</span><span class="val">${value}</span></div>`;
      })
      .join("");

    if (knownCount === 0) {
      return '<div class="muted">Adapter info not exposed by this browser.</div>';
    }

    const note = unknownCount > 0
      ? '<div class="muted" style="margin-top:8px">Some adapter fields were reported as "Unknown" for privacy reasons. </div>'
      : "";

    return rows + note;
  }

  function renderListRows(items, valueKey = "message") {
    if (!Array.isArray(items) || items.length === 0) {
      return null;
    }

    return items
      .map((item) => {
        const phase = item.phase || item.type || "general";
        const message = item[valueKey] || item.message || String(item);
        return `<div class="row"><span>${phase}</span><span class="val">${message}</span></div>`;
      })
      .join("");
  }

  function renderUI() {
    const summary = uiState.summary || emptySummary();
    $("timings").innerHTML = renderTimings(summary.timings);

    const featureSet = new Set([
      ...(uiState.features.adapter || []),
      ...(uiState.features.device || []),
    ]);
    const features = Array.from(featureSet).sort();
    $("features").innerHTML = features.length
      ? features
          .map((feature) => `<span class="tag">${feature}</span>`)
          .join("")
      : '<span class="muted">No features reported.</span>';

    adapterInfoEl.innerHTML = renderAdapterInfo(uiState.info);

    const warningRows = renderListRows(summary.warnings, "warning");
    warningsCard.hidden = !warningRows;
    if (warningRows) {
      warningsEl.innerHTML = warningRows;
    }

    const errorRows = renderListRows(summary.errors);
    errorsCard.hidden = !errorRows;
    if (errorRows) {
      errorsEl.innerHTML = errorRows;
    }

    $("adapterLimits").innerHTML = renderLimits(
      summary.adapterLimits || uiState.limits.adapter,
    );
    $("deviceLimits").innerHTML = renderLimits(
      summary.deviceLimits || uiState.limits.device,
    );
  }

  async function boot() {
    let initWebGPUWithTracking;
    let testComputeWithTimestamps;

    try {
      const diagnostics = await import("./webgpu.js");
      initWebGPUWithTracking = diagnostics.initWebGPUWithTracking;
      testComputeWithTimestamps = diagnostics.testComputeWithTimestamps;
      if (typeof initWebGPUWithTracking !== "function") {
        throw new Error("Diagnostics module missing init function");
      }
    } catch (error) {
      const message = error?.message || "Failed to load diagnostics module";
      console.error("Failed to import diagnostics", error);
      setStatus(false, message);
      loadingEl.style.display = "none";
      renderUI();
      return;
    }

    try {
      const result = await initWebGPUWithTracking({ canvas });
      const tracker = result.tracker;
      const summary =
        result.summary ||
        (tracker && typeof tracker.getSummary === "function"
          ? tracker.getSummary()
          : emptySummary());

      uiState.summary = summary;
      const a = await navigator.gpu?.requestAdapter();

      uiState.info = a !== undefined ? { architecture: a.info.architecture, vendor: a.info.vendor } : null;
      uiState.features = result.features || {
        adapter: [],
        device: [],
      };
      uiState.limits = {
        adapter:
          (result.limits && result.limits.adapter) ||
          summary.adapterLimits ||
          {},
        device:
          (result.limits && result.limits.device) ||
          summary.deviceLimits ||
          {},
      };

      deviceRef = result.device || null;
      contextRef = result.context || canvas.getContext("webgpu") || null;
      canvasFormat = result.canvasFormat || null;

      if (contextRef && !result.context) {
        const format = canvasFormat || navigator.gpu.getPreferredCanvasFormat();
        contextRef.configure({
          device: deviceRef,
          format,
          alphaMode: "premultiplied",
        });
      }

      resizeCanvas();
      if (!resizeObserver) {
        resizeObserver = new ResizeObserver(() => resizeCanvas());
        resizeObserver.observe(canvas);
      }

      if (result.success) {
        setStatus(true, "WebGPU Ready");
        if (result.device && result.errorScope && typeof testComputeWithTimestamps === "function") {
          testComputeWithTimestamps(result.device, result.errorScope).catch(
            (err) => console.warn("Compute diagnostics failed", err),
          );
        }
      } else {
        const failureMessage =
          summary.errors?.[0]?.message ||
          "WebGPU initialization failed";
        setStatus(false, failureMessage);
      }
    } catch (error) {
      const message = error?.message || String(error);
      setStatus(false, message);
      uiState.summary = emptySummary();
      uiState.summary.errors = [
        {
          phase: "boot",
          message,
        },
      ];
    } finally {
      loadingEl.style.display = "none";
      renderUI();
    }
  }

  boot();
</script>
</body>
</html>
